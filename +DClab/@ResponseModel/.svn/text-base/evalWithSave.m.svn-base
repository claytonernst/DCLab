function [y, fileCreated] = evalWithSave(RM, x, domrng, varTrans, nComp)
%EVALWITHSAVE returns (x,y) pairs for a given ResponseModel
%
%   [RESPONSE] = RANDOMEVALWITHSAVE(RM,X,DOMAINRANGES,VARTRANS)
%   evalulates the ResponseModel RM at X that live in the domain range
%   DOMAINRANGES. VARTRANS should be a nx1 cell array containing
%   'none' or 'log10'. For example, if DOMAINRANGES = [1 10; -1 1]] and
%   VARTRANS = {'log10';'none'} the x of all returned pairs will be
%   [10^zeta(1),; zeta(2)] where zeta(1) was drawn from a uniform
%   distribution over [0 1], and zeta(2) was drawn from a uniform
%   distribution over [-1 1]. X contains horizontally
%   concatenated column vectors of x and will be n-by-nevals. RESPONSE
%   contains horizontally concatenated values of y and will be 1-by-nevals.
%   If RM.saveEnabled == true. The evaluation points (x,y) will be saved in
%   a subdirectory of DClabVxxx/savedEvalutations.
%
%   [RESPONSE] = RANDOMEVALWITHSAVE(RM,X,DOMAINRANGES,VARTRANS,NCOMP)
%   distributes the task of evaluating y = M(x) at the design points among
%   NCOMP different networked computers that share a common file server
%   with the local machine. Each of these computers must have the toolbox
%   installed and be running XXX. Set NCOMP = 0 to perform all evaluations
%   on the local machine.
%
%   [RESPONSE, FILECREATED] = RANDOMEVALWITHSAVE(...)
%   additionally returns that name (an integer) of the files in which the
%   (x,y) pairs were saved.
%
%   Inputs:
%   RM: ResponseModel object
%   X: Nparam-by-Nevals
%   DOMAINRANGES: Nparam-by-2 matrix indicating the domain from which to
%      select the design points.
%   VARTRANS: Nparam-by-1 cell array with each cell containing 'none' or
%      'log10'. This input dictates how the design points are distributed.
%   NCOMP: a nonnegative integer indicating the number of computers the
%      task of evaluating the model at the design points should be
%      distributed over. Set this to 0 to perform all computations on the
%      local machine that called this function.

ni = nargin;
switch ni
    case 4
        nComp = 0;
    otherwise
        error(nargchk(4,5,ni))
end


%%%%
%This next chunk is commented out, cause the transformations should have
%already happened for this function...
%%%%

% N = size(x,2);
% 
% %Check that the model is defined on the requested domain.
% modelDomain = RM.domain;
% modelDomain = vertcat(modelDomain.range);
% if ~DClab.issubset(domrng,modelDomain,1e-10,1e-10)
%     error('The domain of the ResponseModel does not contain the requested domain')
% end
% 
% % Create latin hypercube design. But only consider dimensions whose range
% % is nonsingleton
% doesVaryIdx = find(diff(domrng,[],2) > 0);
% % nvary = length(doesVaryIdx);
% %rand('state',sum(100*clock)) %reset rand state
% % if N >= 3*nvary
% %   tmp = DClab.lhsdesign(N,nvary,'smooth','off','criterion','none');
% % else
% %   tmp = rand(N,nvary);
% % end
% tmp = x;
% 
% % Initialize x to be N columns of the lower limits on the ranges. We
% % replace the values for dimensions that are nonsingleton with values
% % generated by the above design.
% x = repmat(domrng(:,1),1,N);
% 
% log10Trans = strmatch('log10',char(varTrans(doesVaryIdx)),'exact');
% noTrans = strmatch('none',char(varTrans(doesVaryIdx)),'exact');
% 
% if any(domrng(doesVaryIdx(log10Trans),1) < 1e-10 )
%     error('log10 transformation occured on one or more dimensions whose lower limit was non positive')
% end
% 
% scale = diag(diff(domrng(doesVaryIdx(noTrans),:),1,2));
% x(doesVaryIdx(noTrans),:) = repmat(domrng(doesVaryIdx(noTrans),1),1,N) + scale*tmp(noTrans,:);
% 
% scale = diag(log10(domrng(doesVaryIdx(log10Trans),2)./domrng(doesVaryIdx(log10Trans),1)));
% x(doesVaryIdx(log10Trans),:) = 10.^(repmat(log10(domrng(doesVaryIdx(log10Trans),1)),1,N) + scale*tmp(log10Trans,:));
% 
% %At this point x is n-by-nevals, in the model's natural coordinates, and
% %the design is complete.

if nComp==0
    % Evaluate model
    switch RM.type
        case {'linearModel','quadraticModel'}
            y = eval(RM,x);
        case 'dcModel'
            try
                y = feval(RM.model,'simulate',x,RM.additionalInputs{:});
            catch
                fprintf('error evaluating model handle %s in randomEvalWithSave\n',func2str(RM.model));
                keyboard
            end
        otherwise
            error('Internal inconsistency: condition should never occur')
    end
else
    %===begin code for multiple computers
    
    % Number of points per chunk (max 500). Each chunk will be assigned to a computer
    nPntsPerChunk = ceil(N/nComp);
    if nPntsPerChunk>500
        nPntsPerChunk=500;
    end
    nChunks = ceil(N/nPntsPerChunk);
    
    xqueue = cell(nChunks,1); %we place each chunk of the design points here
    yqueue = cell(1,nChunks); %we save y=M(x) for each chunk here
    jobNames = cell(nChunks,1);
    done = false(nChunks,1); %this variable tracks which chunks are finished
    chunks = (1:nChunks)';
    sent = []; %here we track which chunks listed in tosend have been allocated
    
    % Break x into a cell array of chunks, each containing at most 500 points
    if nChunks > 1
        for i1 = 1:nChunks-1
            xqueue{i1} = x(:,nPntsPerChunk*(i1-1)+1:nPntsPerChunk*i1);
        end
        xqueue{nChunks} = x(:,nPntsPerChunk*(i1-1)+1:end);
    else
        xqueue{nChunks} = x;
    end
    %create/load jobQueue object
    jobQ = DClab.jobQueue(nComp);
    
    %set all old jobs to old
    oldjobs = isrunning(jobQ);
    for i1 = 1:length(oldjobs)
        jobQ = jobstatus(jobQ,oldjobs{i1},'old');
    end
    
    %find instruction folder
    file = which('multiComputerTempDir');
    tempDir = fileparts(file);
    
    %begin loop
    notDone=1;
    while notDone
        situationUnchanged=true;
        
        tosend = setdiff(chunks(~done),sent);
        
        % If there are no jobs left to send, place all unfinished chunks in the
        % tosend list. This will ensure we are using all our resources.
        if isempty(tosend)
            tosend = chunks(~done);
            sent = []; %null out sent, since we want to restart all chunks in the new tosend list
        end
        
        %create jobs until all the computers are busy
        compAvail = true;
        while compAvail && ~isempty(tosend) %while theres still computers and all the jobs aren't sent
            
            %Give the first chunk in tosend to an available computer.
            try
                [jobQ,compAvail,jobIdx] = createjob(jobQ,builtin('struct','distribute','modelEvals','ResponseModel',RM,'designPoints',xqueue{tosend(1)}));
            catch
                disp('failed call to createjob')
                keyboard
            end
            
            if compAvail
                situationUnchanged = false;
                sent = [sent; tosend(1)];
                if isempty(jobNames{tosend(1),1})
                    jobNames{tosend(1),1} = jobIdx;
                else
                    jobNames{tosend(1),end+1} = jobIdx;
                end
                tosend(1) = [];
            end
        end
        
        %check for complete jobs by searching for files
        D = dir(tempDir);
        outfiles = strmatch('Evals',{D.name});
        
        %grab finished information
        if ~isempty(outfiles)
            situationUnchanged=false;
            
            %do an initial pause until saving of files in current outfile
            %list is completed.
            pause(3)
            
            %loop through current finished files
            for i1 = outfiles'
                
                %parse out jobLabel
                tmp = strfind(D(i1).name,'job');
                try
                    tmp = D(i1).name(tmp+3:end);
                    jobLabel = tmp(1:end-4);
                catch
                    disp('line 225')
                    keyboard
                end
                if strcmp(jobstatus(jobQ,jobLabel),'old') %if old job
                    
                    jobQ = jobstatus(jobQ,jobLabel,'done'); %change to done
                    initialPause = 0; %we shouldn't need to wait for an old
                    %file to finish saving
                    DClab.robustDelete([tempDir filesep D(i1).name], initialPause);  %delete output file
                    
                else                                      %if not old
                    
                    initialPause = 0; %hopefully the pause on line 214 was sufficient
                    %for the file to finish saving
                    
                    DClab.robustLoad([tempDir filesep D(i1).name],initialPause)  %load the file
                    if exist('a','var')
                        s = a; %assign variable
                    else
                        disp('problem loading file')
                        keyboard
                    end
                    
                    loc = find(strcmp(jobNames,jobLabel));
                    if ~isequal(s.x,xqueue{loc})
                        disp('The loaded x values are not what they should be')
                        keyboard
                    end
                    
                    if done(loc)
                        %this set of points was completed by a different computer, throw it away
                    else
                        %use it
                        done(loc) = true;
                        yqueue{1,loc} = s.y;
                    end
                    
                    jobQ = jobstatus(jobQ,jobLabel,'done'); %change to done
                    initialPause = 0.25;
                    DClab.robustDelete([tempDir filesep D(i1).name],initialPause);  %delete output file
                    
                end %if old job
                clear a s tempout
                
            end %for i1 = outfiles'
            
            if all(done)
                notDone = false;
            end
            
        end % if ~isempty(outfiles)
        
        %if nothing happening (no new jobs created, no jobs just completed), wait
        %2 seconds and check again
        if situationUnchanged
            pause(2);
        end
        
    end %while notDone
    
    y = [yqueue{:}];
    if size(y,2) ~= N
        disp('issues in randomEvalWithSave eval')
        keyboard
    end
    
    %===end code for multiple computers
    
end

% Deal with the possibility of multiple responses
addl = RM.additionalInputs;
if RM.multipleResponsesEnabled
    %if enabled both featPrec and featList should be nonempty and
    %addlInputs should be at least length 1
    respSimSeg = RM.responseSimulationSegment;
    respList = RM.responseList;
    idx1 = strmatch(RM.additionalInputs{1},char(respList),'exact');
    if ~isempty(respSimSeg)
        respList = respList(respSimSeg <= respSimSeg(idx1));
        idxOfRequestedResponse = strmatch(RM.additionalInputs{1},char(respList),'exact');
    else
        idxOfRequestedResponse = idx1;
    end
    
else
    respList = {};
    idxOfRequestedResponse = 1;
end

% Save output if requested
if ~strcmp(RM.type,'dcModel') || RM.saveEnabled~=1
    fileCreated = [];
else
    %====save evaluations
    modelname = func2str(RM.model);
    
    for i1 = 1:size(y,1)
        tmpaddl = addl;
        
        %If respList is nonempty, it means multiple responses were computed. In
        %this situation, the first element of addl will be an element of
        %respList. Temporarily overwrite this so that we save the correct
        %response with the correct response name
        if ~isempty(respList)
            tmpaddl{1} = respList{i1};
        end
        
        %Determine the name of the directory the i1'th response will be saved
        %in
        name = modelname;
        for i2 = 1:length(tmpaddl)
            if ischar(tmpaddl{i2})
                name = [name '_' tmpaddl{i2}]; %#ok
            elseif isnumeric(tmpaddl{i2})
                name = [name '_' num2str(tmpaddl{i2})]; %#ok
            else
                error('Internal inconsistency: condition should never occur')
            end
        end
        
        %Create the structure that will be saved.
        s.name = name;
        s.mhandle = RM.model;
        s.domainRange = domrng;
        s.paramValues = x;
        s.responses = y(i1,:);
        s.variableTransformations = varTrans;
        
        name = strrep(name,'.','p');
        
        file = which('savedEvaluationsDir');
        evalPath = fileparts(file);
        dirName = fullfile(evalPath,name);
        if ~exist(dirName,'dir')
            if mkdir(evalPath,name) ~= 1
                disp('directory not created')
                keyboard
            end
        end
        
        %load the catelog file
        catFileName = fullfile(dirName,[name '.mat']);
        if exist(catFileName,'file')
            % robustLoad(catFileName,0.1);
            load(catFileName);
            catelog = a;
            idx = length(catelog)+1;
        else
            catelog = struct([]);
            idx = 1;
        end
        
        %Output the fileCreated that corresponds to the response of the
        %supplied ResponseModel
        if i1 == idxOfRequestedResponse
            fileCreated = idx;
        end
        
        evalsFileName = fullfile(dirName,num2str(idx));
        %robustSave(evalsFileName,s);
        a = s;
        save(evalsFileName,'a');
        
        catelog(idx).domainRange = domrng;
        catelog(idx).variableTransformations = varTrans;
        catelog(idx).forGrad = false;
        %robustSave(catFileName,catelog);
        a = catelog;
        save(catFileName,'a');
    end % i1 = 1:length(respList)
    
end

%Pull out the final output
y = y(idxOfRequestedResponse,:);
