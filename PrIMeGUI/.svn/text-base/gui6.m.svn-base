function varargout = gui6(varargin)
% GUI6 -- main data collaboration gui.
%
% To edit the gui using guide, type
% >> tabpanel('gui6','tp')
%
% NEVER EXECUTE THIS COMMAND WITH THE GUI OPEN.
%
% Due to limitations of the tabpanel function and our desire to have
% certain gui components appear in multiple tabs, the resulting gui will
% differ somewhat from the actual gui that is produced by
%
% >> gui6
%
% These differences are generated by lines of code in this file.
% Predominately in the "tweakUI" section
%
%
%
%
%
% ===Description of handles structure===
%                           figure1: mainfig
%                                tp: [1x15 double]
%  tp_OptimizeModelPar_AnalyzePanel: Optimization Results and Button
%tp_OptimizeModelPar_OptimWeightsPB: Button to edit optimization weights
% tp_PerformPrediction_AnalyzePanel: Prediction Results and Button
%    tp_PerformPrediction_DsetPanel: DCDataset Panel for param mods
%   tp_PerformPrediction_ModelPanel: Model Panel for param mods
%  tp_CheckConsistency_AnalyzePanel: Consistency Results and Button
%     tp_CheckConsistency_DsetPanel: DCDataset Panel for no param mods
%    tp_CheckConsistency_ModelPanel: Model Panel for no param mods
%                              Help: file menu
%                      messagepanel: Panel to display messages
%                        guioptions: file menu
%                           Options: file menu (analysis)
%                              Edit: file menu
%                              File: file menu
%                       FitParamsPB: Optimize Model Button
%                 optimResultsPanel: Panel for OptimResults Listbox
%                             About: in Help menu
%                           GUIHelp: in Help menu
%                            PredPB: Prediction Button
%                  predResultsPanel: Panel for Pred Results Listbox
%                         PDomPanel: Panel to display mod param ranges
%                            DsetPB: [1x2] both add Dset push buttons
%                           ad_text: [1x2] Add DCDataset text
%                          DsetList: [1x2] Both Avail. Dset listboxes
%                           ModelPB: [1x2] Both add Model push buttons
%                          apm_text: [1x2] Add Pred Model text
%                         ModelList: [1x2] Both Avail Model listboxes
%                         ConsistPB: Check Consistency Button
%               consistResultsPanel: Panel for Consist Results listbox
%                          guismall: in guioptions menu
%                       normsizegui: in guioptions menu
%                            logoff: in guioptions menu
%                          clearlog: in guioptions menu
%                             logon: in guioptions menu
%                         messageLB: Listbox to display messages
%                            advOpt: in Analysis Options menu
%                            stdOpt: in Analysis Options menu
%                         EditModel: in Edit menu
%                          EditDset: in Edit menu
%                             Close: in File menu
%                            SaveAs: in File menu
%                              Save: in File menu
%                              Open: in File menu
%                             prime: in File menu
%                    OptimResultsLB: Listbox for optimization results
%                     PredResultsLB: Listbox for prediction results
%                            PDomPU: Popup to disp current param ranges
%                  ConsistResultsLB: Listbox for consistency results
%                           RemoveM: in Edit Model file menu
%                           RenameM: in Edit -> Edit Model menu
%                              NewM: in Edit -> Edit Model menu
%                          ModParam: in Edit -> Edit DCDataset menu
%                           RemoveD: in Edit -> Edit DCDataset menu
%                           RenameD: in Edit -> Edit DCDataset menu
%                             EditD: in Edit -> Edit DCDataset menu
%                              NewD: in Edit -> Edit DCDataset menu
%                            output: Default gui output (unused)
%                   sessionModified: Bool to track changes for save prompt
%                  prevguiheight: track psuedo height w/o message box
%
%  The rest are filled out from a guisession object by calling addguiobj
%
%               options: Current DCOptions
%           DatasetUnit: Cellarray of multidim DSetUnit objects
%                 Model: Cellarray of predictor MAssns
%                  ModP: Cellarray of modified PAssn objects
%           ConsistTest: Cellarray of created ConsistTest objs
%            Prediction: Cellarray of created Prediction objs
% ParameterOptimization: Cellarray of created ParameterOptimization objs
%             UnitArray: Stored DatasetUnits avail for Dset creation
%              ParamAss: Stored Default Parameter Assn objects
%                MAcell: Stored MAssns that may be added as surrogate models
%
%
% GUI6 M-file for gui6.fig
%      GUI6, by itself, creates a new GUI6 or raises the existing
%      singleton*.
%
%      H = GUI6 returns the handle to a new GUI6 or the handle to
%      the existing singleton*.
%
%      GUI6('CALLBACK',hObject,eventData,handles,...) calls the local
%      function named CALLBACK in GUI6.M with the given input arguments.
%
%      GUI6('Property','Value',...) creates a new GUI6 or raises the
%      existing singleton*.  Starting from the left, property value pairs are
%      applied to the GUI before gui6_OpeningFunction gets called.  An
%      unrecognized property name or invalid value makes property application
%      stop.  All inputs are passed to gui6_OpeningFcn via varargin.
%
%      *See GUI Options on GUIDE's Tools menu.  Choose "GUI allows only one
%      instance to run (singleton)".
%
% See also: GUIDE, GUIDATA, GUIHANDLES

% Edit the above text to modify the response to options gui6

% Last Modified by GUIDE v2.5 22-Feb-2010 14:58:04

%Pragmas for compiling:
%#function About_Callback addguiobj advOpt_Callback clearlog_Callback
%#function Close_Callback ConsistPB_Callback ConsistResultsLB_Callback
%#function ConsistResultsLB_CreateFcn DsetList_Callback DsetList_CreateFcn
%#function DsetPB_Callback Edit_Callback EditD_Callback EditDset_Callback
%#function EditModel_Callback figure1_CloseRequestFcn figure1_ResizeFcn
%#function File_Callback FitParamsPB_Callback getParamAss gui6_OpeningFcn
%#function gui6_OutputFcn GUIHelp_Callback guioptions_Callback
%#function guismall_Callback Help_Callback logoff_Callback logon_Callback
%#function messageLB_Callback messageLB_CreateFcn ModelList_Callback
%#function ModelList_CreateFcn ModelPB_Callback ModelParam_Callback
%#function NewD_Callback NewM_Callback normsizegui_Callback Open_Callback
%#function OptimResultsLB_Callback OptimResultsLB_CreateFcn
%#function Options_Callback PDomPU_Callback PDomPU_CreateFcn PredPB_Callback
%#function PredResultsLB_Callback PredResultsLB_CreateFcn primeAs_Callback
%#function stdOpt_Callback tabclick_Callback timer_Callback
%%#functtion tp_OptimizeModelPar_OptimWeightsPB_Callback
%%#functtion tp_OptimizeModelPar_OptimOptionsPB_Callback


% Begin initialization code - DO NOT EDIT
gui_Singleton = 1;
gui_State = struct('gui_Name',       mfilename, ...
    'gui_Singleton',  gui_Singleton, ...
    'gui_OpeningFcn', @gui6_OpeningFcn, ...
    'gui_OutputFcn',  @gui6_OutputFcn, ...
    'gui_LayoutFcn',  [] , ...
    'gui_Callback',   []);
if nargin && ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end

if nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
    gui_mainfcn(gui_State, varargin{:});
end
% End initialization code - DO NOT EDIT

% --- Executes just before gui6 is made visible.
function gui6_OpeningFcn(hObject, eventdata, handles, varargin) %#ok
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% varargin   command line arguments to gui6 (see VARARGIN)

%====BEGIN TWEAK THE UI APPEARANCE====

%===place the uipanels in the correct tab panel===
%we've cheated a bit, in that when we originally constructed the panels
%within the tabs, we didn't put them in the right places. this allows us to
%create duplicate datasetlist displays so we can swap in the one with the
%parameter domain added when needed.
set(handles.figure1,'name','Data Collaboration');
set(handles.File,'visible','off');
%set(handles.advOpt,'visible','off');
set(handles.GUIHelp,'visible','off');

%Optimize Model
set(handles.tp(11),'UserData',{'tp_CheckConsistency_DsetPanel',...
    'tp_OptimizeModelPar_AnalyzePanel','tp_OptimizeModelPar_OptimWeightsPB','tp_OptimizeModelPar_OptimOptionsPB'});

%PerformPrediction
set(handles.tp(12),'UserData',{'tp_CheckConsistency_DsetPanel',...
    'tp_CheckConsistency_ModelPanel','tp_PerformPrediction_AnalyzePanel'});

%CheckConsistency
set(handles.tp(13),'UserData',{'tp_CheckConsistency_DsetPanel',...
    'tp_CheckConsistency_AnalyzePanel'});
%===end place the uipanels in the correct tab panels

%hide the panels we don't want to see
set(handles.tp_PerformPrediction_DsetPanel,'Visible','off')
set(handles.tp_PerformPrediction_ModelPanel,'Visible','off')
%set(handles.tp_OptimizeModelPar_SettingsPanel,'Visible','off')

%add spaces to tab names
%click CheckConsistency to we can be consistent with UserData.current
tabclick_Callback(handles.tp(13))
set(handles.tp(11),'String','Optimize Model Parameters')
% set(handles.tp(11),'Callback','gui6(''tabclick_Callback'',gcbo,[],guidata(gcbo))');
set(handles.tp(11),'Callback', @(h,d) gui6('tabclick_Callback',gcbo,[],guidata(gcbo)) );
set(handles.tp(12),'String','Perform Prediction')
% set(handles.tp(12),'Callback','gui6(''tabclick_Callback'',gcbo,[],guidata(gcbo))');
set(handles.tp(12),'Callback', @(h,d) gui6('tabclick_Callback',gcbo,[],guidata(gcbo)) );
set(handles.tp(13),'String','Check Consistency')
% set(handles.tp(13),'Callback','gui6(''tabclick_Callback'',gcbo,[],guidata(gcbo))');
set(handles.tp(13),'Callback', @(h,d) gui6('tabclick_Callback',gcbo,[],guidata(gcbo)) );
UserData = get(handles.tp(15),'UserData');
UserData.names = {'Check Consistency'  'Perform Prediction'  'Optimize Model Parameters'};
UserData.current = 'Check Consistency'; %we can do this since we just 'clicked' it
set(handles.tp(15),'UserData',UserData)

%make tabpanels the system color
%grab user data from the storage object (the last tp handle)
tpctab = get(handles.tp(end),'UserData');
dcolor = get(0,'defaultUicontrolBackgroundColor');
tpctab.CurrBackColor = dcolor; %sets the tab buttons color
% the previous line doesn't work with the XP (as opposed to classic)
% windows display mode. We'll cheat by increasing one of the three colors

dcolor(1) = dcolor(1)+0.002;
dcolor(3) = dcolor(3)-0.002;
tpctab.CurrBackColor = dcolor;

%lighten the unselected tabs
tcptab.BackColor = [0.68 0.68 0.68];

set(handles.tp(end),'UserData',tpctab);
set(handles.tp(end-1),'Color',dcolor) %sets the axis color
panels = [handles.tp_OptimizeModelPar_AnalyzePanel; handles.tp_PerformPrediction_AnalyzePanel;...
    handles.tp_PerformPrediction_DsetPanel; handles.tp_PerformPrediction_ModelPanel;...
    handles.tp_CheckConsistency_AnalyzePanel; handles.tp_CheckConsistency_DsetPanel;...
    handles.tp_CheckConsistency_ModelPanel; handles.PDomPanel];
set(panels,'BackgroundColor',dcolor);

textboxes = [handles.ad_text handles.apm_text handles.results_text];
set(textboxes,'BackgroundColor',dcolor)

set(handles.figure1,'Color',get(0,'defaultFigureColor')) %make the background behind the tabs a different color

if length(varargin)<4 || ~varargin{4}
    %leave the CheckConsistency tab and return to it to refresh the display
    tabclick_Callback(handles.tp(11))
    tabclick_Callback(handles.tp(12))
    tabclick_Callback(handles.tp(13))
else
    %leave the CheckConsistency tab and move to prediction tab to refresh the display
    tabclick_Callback(handles.tp(11))
    tabclick_Callback(handles.tp(13))
    tabclick_Callback(handles.tp(12))
end

%===set enable properties of various object===
%the execute pushbuttons
set([handles.PredPB handles.ConsistPB handles.FitParamsPB handles.tp_OptimizeModelPar_OptimWeightsPB],'enable','off')
set([handles.PredPB handles.ConsistPB handles.FitParamsPB handles.tp_OptimizeModelPar_OptimOptionsPB],'enable','off')

%the filemenus
set([handles.RemoveD,handles.EditD,handles.ModParam,handles.RenameD],'enable','off')
set([handles.RemoveM,handles.RenameM],'enable','off')
set(handles.logoff,'enable','off')
set(handles.clearlog,'enable','off')
set(handles.Save,'enable','off')

%context menus
set(handles.ConsistResultsLB,'uicontextmenu',handles.tp_CheckConsistency_context)
set(handles.PredResultsLB,'uicontextmenu',handles.tp_PerformPrediction_context)
set(handles.warm_run,'enable','off')
set(handles.view_opt,'enable','off')

%make everything porportional
set(handles.tp_OptimizeModelPar_AnalyzePanel,'Units','Normalized')
set(handles.tp_OptimizeModelPar_OptimWeightsPB,'Units','Normalized')
set(handles.tp_OptimizeModelPar_OptimOptionsPB,'Units','Normalized')
set(handles.tp_PerformPrediction_AnalyzePanel,'Units','Normalized')
set(handles.tp_PerformPrediction_ModelPanel,'Units','Normalized')
set(handles.tp_PerformPrediction_DsetPanel,'Units','Normalized')
set(handles.tp_CheckConsistency_AnalyzePanel,'Units','Normalized')
set(handles.tp_CheckConsistency_DsetPanel,'Units','Normalized')
set(handles.tp_CheckConsistency_ModelPanel,'Units','Normalized')
set(handles.tp,'Units','Normalized')
set(handles.figure1,'resize','on')

%establish sizes etc for message box
set(handles.messageLB,'string',{})
set(handles.messagepanel,'visible','off','Units','Normalized')
pos = [0.02 0.02 0.96 0.19];
set(handles.messagepanel,'position',pos)
set(handles.messageLB,'Units','Normalized')
set(handles.messageLB,'position',[0.025 0.07 0.95 0.9]);

%%fix background color for OptimNormPU
%if ispc && isequal(get(handles.OptimNormPU,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
%    set(handles.OptimNormPU,'BackgroundColor','white');
%end

%====END TWEAK THE UI APPEARANCE

% Choose default command line output for gui6
handles.output = hObject;

handles.sessionModified = false;

guipos = get(handles.figure1,'position');
handles.prevguiheight = guipos(4);

%===Fill out default values for all additional fields===
guiobj = DClab.Guisession; %create empty session object
switch length(varargin)
    case 0
        %do nothing
    case 2
        guiobj.UnitArray = varargin{1};
        guiobj.FreeParameter = varargin{2};
    case {3,4}
        guiobj.UnitArray = varargin{1};
        guiobj.FreeParameter = varargin{2};
        guiobj.RMcell = varargin{3};
    otherwise
        error('Incorrect number of inputs to GUI6')
end
handles = addguiobj(guiobj,handles);
handles.OptimOptns = {};

%the previous call should have initialized the following
%  .options = DClab.DCOptions;
%  .DatasetUnit = {};
%  .Model = {};
%  .ModP = {FreeParameter};
%  .ConsistTest = {};
%  .Prediction = {};
%  .ParameterOptimization = {};
%  .UnitArray % column array of dataset units
%  .ParamAss %column array of parameter assertions
%  .MAcell % column cell array of model assertions

% In handles.ModP, we store any changes to the default parameter ranges.
% Initially, there are no changes, and the select parameter ranges list box
% is hidden from the user. The parameters stored in
% handles.ParamAss will be treated as all assertions that are globally
% available (e.g., from prime). Named collections of dataset units are called
% datasets in the gui. However, these are DatasetUnit objects, not DCDataset
% objects. When the user performs an analysis on a named collection of
% units, we will form a dataset object by adding to it the needed
% parameter assertions by first grabing them from the global list, and then
% making any changes that are indicated in the selected handles.ModP.

% Timer to periodically refresh the gui during computation
handles.timer = timer('executionmode','fixedrate',...
    'TimerFcn',@timer_Callback,'Period',0.5,'startdelay',2,'UserData',hObject);
start(handles.timer);

guidata(hObject, handles);

% --- Outputs from this function are returned to the command line.
function varargout = gui6_OutputFcn(hObject, eventdata, handles) %#ok
% varargout  cell array for returning output args (see VARARGOUT);
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get default command line output from handles structure
varargout{1} = handles.output;

%=======create functions========

% --- Executes during object creation, after setting all properties.
function DsetList_CreateFcn(hObject, eventdata, handles) %#ok
% hObject    handle to DsetList (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: listbox controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

% --- Executes during object creation, after setting all properties.
function ModelList_CreateFcn(hObject, eventdata, handles) %#ok
% hObject    handle to ModelList (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: listbox controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function ConsistResultsLB_CreateFcn(hObject, eventdata, handles) %#ok
% hObject    handle to PDomList_context_menu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: listbox controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function PredResultsLB_CreateFcn(hObject, eventdata, handles) %#ok
% hObject    handle to PDomList_context_menu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: listbox controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function OptimResultsLB_CreateFcn(hObject, eventdata, handles) %#ok
% hObject    handle to PDomList_context_menu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: listbox controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function messageLB_CreateFcn(hObject, eventdata, handles) %#ok
% hObject    handle to messageLB (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: listbox controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function PDomPU_CreateFcn(hObject, eventdata, handles) %#ok

% Hint: popupmenu controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

%========Call Backs========
function PDomPU_Callback(hObject, eventdata, handles) %#ok

function DsetList_Callback(hObject, eventdata, handles) %#ok

%This code updates the DsetList of both the default panel and the one with the parameter mods upon selection in any one panel
val = get(hObject,'Value');
set(handles.DsetList,'Value',val)

if strcmp(get(handles.figure1,'SelectionType'),'open') && numel(get(hObject,'String')) > 0
    EditD_Callback(handles.EditD,eventdata,handles);
end

function ModelList_Callback(hObject, eventdata, handles) %#ok
%This code updates the ModelList of both the default panel and the smaller one used with the parameter mods upon selection in any one panel
val = get(hObject,'Value');
set(handles.ModelList,'Value',val)


str = get(hObject,'String');
if strcmp(get(handles.figure1,'SelectionType'),'open') && numel(str) > 0
    ModelViewer(handles.Model{val},str{val});
end

function DsetPB_Callback(hObject, eventdata, handles) %#ok
if isempty(handles.UnitArray)
    msgbox('No DatasetUnits are available, use the file menu to open a session','We''re sorry','warn','modal')
    return
end

% Launch gui that allows you to select units to build a dataset
[idx name] = DatasetUnitImport(cellstr(get(handles.DsetList(1),'String')),handles.UnitArray);

if isempty(idx)
    return
end

% Add selected collection of units to the list of datasets. In the GUI, we
% call a collection of units a "dataset", even though it is not a "DCDataset"
% object because all the parameter stuff is handled behind the scenes. When
% ever we need a collection of dataset units to be a DCDataset object, we
% just add in the needed parameters automatically.
if ~isempty(handles.DatasetUnit)
    handles.DatasetUnit{end+1,1} = handles.UnitArray(idx);
    handles.DatasetUnitInfo(end+1,1).def_d = vertcat(handles.UnitArray(idx).observedValue);
else
    handles.DatasetUnit = {handles.UnitArray(idx)};
    handles.DatasetUnitInfo(1,1).def_d = vertcat(handles.UnitArray(idx).observedValue);
end
handles.DatasetUnitInfo(end,1).def_uncVect = vertcat(handles.UnitArray(idx).observationUncertaintyPlusMinus);
handles.DatasetUnitInfo(end,1).isdef = true(length(idx),1);
handles.DatasetUnitInfo(end,1).curwt = 2./diff(vertcat(handles.DatasetUnit{end}.observationUncertaintyPlusMinus),[],2);

%save the lines of the results displays that correspond to this dataset so
%we can remove them if the dataset is ever removed.
handles.DatasetUnitInfo(end,1).consistResults = [];
handles.DatasetUnitInfo(end,1).predResults = [];
handles.DatasetUnitInfo(end,1).optimResults = [];

% Update the Dataset Listbox and highlight the one just created.
str = [get(handles.DsetList(1),'String');{name}];

set(handles.DsetList,'String',str)
set(handles.DsetList,'Value',length(str))

if numel(handles.Model) > 0
    set(handles.PredPB,'enable','on')
end
set([handles.ConsistPB handles.FitParamsPB handles.tp_OptimizeModelPar_OptimWeightsPB handles.tp_OptimizeModelPar_OptimOptionsPB],'enable','on')
set([handles.RemoveD,handles.EditD,handles.ModParam,handles.RenameD],'enable','on')
handles.sessionModified = true;
guidata(hObject,handles);
refresh

function ModelPB_Callback(hObject, eventdata, handles) %#ok

if isempty(handles.MAcell)
    msgbox('No surrogate models are available, use the file menu to open a session','We''re sorry','warn','modal')
    return
else
    [idx name] = ModelImport(cellstr(get(handles.ModelList(1),'String')),handles.MAcell);
end

if isempty(idx)
    return
end

if ~isempty(handles.Model)
    handles.Model{end+1,1} = handles.MAcell{idx};
    %save the lines of the results display that correspond to this model so
    %we can remove them if the model is ever removed.
    handles.ModelInfo(end+1,1).predResults = [];
else
    handles.Model = handles.MAcell(idx);
    handles.ModelInfo.predResults = [];
end

% Update the Model Listbox and highlight the one just created.
str = [get(handles.ModelList(1),'String');{name}];
set(handles.ModelList,'String',str)
set(handles.ModelList,'Value',length(str))

if numel(handles.DatasetUnit) > 0
    set(handles.PredPB,'enable','on')
end
set([handles.RemoveM,handles.RenameM],'enable','on')
handles.sessionModified = true;
guidata(hObject,handles);
refresh

function neededParamAss = getParamAss(handles,plist)
% function to obtain assertions for all parameters in plist. If a modified
% range is selected, these values will override the defaults (currently
% stored in handles.ParamAss) as appropriate.
allparams = {handles.ParamAss.name}';
[trash all2sorted] = intersect(allparams, plist); %#ok
if length(plist) ~= length(trash)
    errordlg('Operation with selected Dataset and/or Model requires parameters that are not available')
    neededParamAss = [];
    return
end

needed = sort(all2sorted);
neededParamAss = handles.ParamAss(needed);

%Make any modifications
currentModP = handles.ModP{get(handles.PDomPU,'Value')};
if ~isempty(currentModP)
    modNames = currentModP.name;
    toEdit = findIdx(neededParamAss,modNames); %call ParamAss method to see where modNames are
    for i1 = 1:length(toEdit)
        if ~isnan(toEdit(i1))
            neededParamAss(toEdit(i1)) = currentModP(i1);
        end
    end
end

% --- Executes on button press in Execute.
function ConsistPB_Callback(hObject, eventdata, handles) %#ok
if handles.options.omitInnerBound && handles.options.omitOuterBound
    msgbox('All bounds are disabled, modify the analysis options and retry','We''re sorry','warn','modal')
    return
end

oldBackgroundColor = get(hObject,'BackgroundColor');
set(hObject,'enable','off','string','Busy','BackgroundColor',[0.6 0.1 0.1])
drawnow

idx = get(handles.DsetList(1),'value');
DsetUnit = handles.DatasetUnit{idx};

% get current (defaults + any selected modifications) parameter assertions for all needed parameters
plist = neededParameters(DsetUnit);
neededParamAss = getParamAss(handles,plist);

%why is this code here? won't there alway be some needed parameters?
if isempty(neededParamAss)
    set(hObject,'enable','on','backgroundColor',...
        oldBackgroundColor,'string','Check Consistency of Highlighted Dataset')
    guidata(hObject,handles)
    return
end

%Attempt the the consistency test
try
    Dset = DClab.DCDataset(DsetUnit,neededParamAss); %create the dataset
    
    %Determine the DCDataset name
    str = get(handles.DsetList(1),'String');
    if numel(handles.ModP) > 1
        pstr = get(handles.PDomPU,'String');
        pname = pstr{get(handles.PDomPU,'Value')};
        if strcmp(pname,'default')
            name = str{idx};
        else
            name = [str{idx} ' with param. ranges ' pname ];
        end
    else
        name = str{idx};
    end
    Dset.name = name;
    
    %Perform the Consistency Test
    obj = DClab.ConsistencyTest(Dset,handles.options);
    LB = obj.LB;
    UB = obj.UB;
    if ~isempty(handles.ConsistTest)
        handles.ConsistTest{end+1,1} = obj;
    else
        handles.ConsistTest = {obj};
    end
    
    %Create the result display string
    if isnan(LB)
        if UB < 0
            newline = ['Dataset ' name ' is inconsistent: consistency measure upper bound is ' num2str(UB,'%0.2f')];
        else
            newline = ['Consistency of Dataset ' name ' is inconclusive: consistency measure upper bound is ' num2str(UB,'%0.2f')];
        end
    elseif isnan(UB)
        if LB > 0
            newline = ['Dataset ' name ' is consistent: consistency measure lower bound is ' num2str(LB,'%0.2f')];
        else
            newline = ['Consistency of Dataset ' name ' is inconclusive: consistency measure lower bound is ' num2str(LB,'%0.2f')];
        end
    else %they won't both be nan, since we abort if no bounds are selected
        if LB > 0
            newline = ['Dataset ' name ' is consistent: measure in [' num2str(LB,'%0.2f') ', ' num2str(UB,'%0.2f') ']'];
        elseif UB < 0
            newline = ['Dataset ' name ' is inconsistent: measure in [' num2str(LB,'%0.2f') ', ' num2str(UB,'%0.2f') ']'];
        else
            newline = ['Consistency of Dataset' name ' is inconclusive: measure in [' num2str(LB,'%0.2f') ', ' num2str(UB,'%0.2f') ']'];
        end
    end
    % Update the Results Listbox and highlight the one just created.
    str = [get(handles.ConsistResultsLB,'String');{newline}];
    set(handles.ConsistResultsLB,'String',str)
    set(handles.ConsistResultsLB,'Value',length(str))
    
    %enable context menus
    set([handles.warm_run(1) handles.view_opt(1)],'enable','on')
    
    % Associate this line of the results with this dataset
    handles.DatasetUnitInfo(idx).consistResults(end+1) = length(str);
    
    set(handles.ConsistPB,'enable','on','backgroundColor',...
        oldBackgroundColor,'string','Check Consistency of Highlighted Dataset')
    handles.sessionModified = true;
    guidata(hObject,handles)
catch
    set(handles.ConsistPB,'enable','on','backgroundColor',...
        oldBackgroundColor,'string','Check Consistency of Highlighted Dataset')
    errordlg([lasterr ': Computation failed'])
end

% --- Executes on button press in PredPB.
function PredPB_Callback(hObject, eventdata, handles) %#ok
if handles.options.omitInnerBound && handles.options.omitOuterBound
    msgbox('All bounds are disabled, modify the analysis options and retry','We''re sorry','warn','modal')
    return
end

oldBackgroundColor = get(hObject,'BackgroundColor');
set(hObject,'enable','off','string','Busy','BackgroundColor',[0.6 0.1 0.1])
drawnow

idx = get(handles.DsetList(1),'value');
DsetUnit = handles.DatasetUnit{idx};
midx = get(handles.ModelList(1),'value');
mstr = get(handles.ModelList(1),'String');
mname = mstr{midx};
M = handles.Model{midx};
M.name = mname;

Mparams = M.parameterList;
Dparams = neededParameters(DsetUnit);

% get current (defaults + any selected modifications) parameter assertions for all needed parameters
neededParamAss = getParamAss(handles,unique(vertcat(Mparams,Dparams)));

%why is this code here? won't there alway be some needed parameters?
if isempty(neededParamAss)
    set(handles.PredPB,'enable','on','BackgroundColor',oldBackgroundColor,...
        'string','Compute Range of Highlighted Model based on Highlighted Dataset')
    guidata(hObject,handles)
    return
end

%Attempt the the prediction call
try
    Dset = DClab.DCDataset(DsetUnit,neededParamAss); %create the dataset
    
    %Determine the DCDataset name
    str = get(handles.DsetList(1),'String');
    if numel(handles.ModP) > 1
        pstr = get(handles.PDomPU,'String');
        pname = pstr{get(handles.PDomPU,'Value')};
        if strcmp(pname,'default')
            name = str{idx};
        else
            name = [str{idx} ' with param. ranges ' pname ];
        end
    else
        name = str{idx};
    end
    Dset.name = name;
    
    %check consistency first
    predidx = handles.DatasetUnitInfo(idx).predResults;
    ctestidx = handles.DatasetUnitInfo(idx).consistResults;
    if ~isempty(predidx) %if there was a prediction, then have consistency
        CTobj.LB=1;
    elseif ~isempty(ctestidx)
        CTobj = handles.ConsistTest{ctestidx(1)};
    else
        opt = handles.options;
        opt = set(opt,'omitInnerBound',0,'omitOuterBound',0);
        CTobj = DClab.ConsistencyTest(Dset,opt);
        
        UB = CTobj.UB;
        LB = CTobj.LB;
        if ~isempty(handles.ConsistTest)
            handles.ConsistTest{end+1,1} = CTobj;
        else
            handles.ConsistTest = {CTobj};
        end
        
        %Create the result display string
        if isnan(LB)
            if UB < 0
                newline = ['Dataset ' name ' is inconsistent: consistency measure upper bound is ' num2str(UB,'%0.2f')];
            else
                newline = ['Consistency of Dataset ' name ' is inconclusive: consistency measure upper bound is ' num2str(UB,'%0.2f')];
            end
        elseif isnan(UB)
            if LB > 0
                newline = ['Dataset ' name ' is consistent: consistency measure lower bound is ' num2str(LB,'%0.2f')];
            else
                newline = ['Consistency of Dataset ' name ' is inconclusive: consistency measure lower bound is ' num2str(LB,'%0.2f')];
            end
        else %they won't both be nan, since we abort if no bounds are selected
            if LB > 0
                newline = ['Dataset ' name ' is consistent: measure in [' num2str(LB,'%0.2f') ', ' num2str(UB,'%0.2f') ']'];
            elseif UB < 0
                newline = ['Dataset ' name ' is inconsistent: measure in [' num2str(LB,'%0.2f') ', ' num2str(UB,'%0.2f') ']'];
            else
                newline = ['Consistency of Dataset' name ' is inconclusive: measure in [' num2str(LB,'%0.2f') ', ' num2str(UB,'%0.2f') ']'];
            end
        end
        % Update the Results Listbox and highlight the one just created.
        str = [get(handles.ConsistResultsLB,'String');{newline}];
        set(handles.ConsistResultsLB,'String',str)
        set(handles.ConsistResultsLB,'Value',length(str))
        
        %enable context menus
        set([handles.warm_run(1) handles.view_opt(1)],'enable','on')
        
        % Associate this line of the results with this dataset
        handles.DatasetUnitInfo(idx).consistResults(end+1) = length(str);
        
        set(handles.ConsistPB,'enable','on','backgroundColor',...
            oldBackgroundColor,'string','Check Consistency of Highlighted Dataset')
        handles.sessionModified = true;
        guidata(hObject,handles)
    end
    if CTobj.LB>0
        
        %Call the prediction code
        obj = DClab.ResponsePrediction(M,Dset,handles.options);
        if ~isempty(handles.Prediction)
            handles.Prediction{end+1,1} = obj;
        else
            handles.Prediction = {obj};
        end
        LBo = obj.LBo;
        LBi = obj.LBi;
        UBi = obj.UBi;
        UBo = obj.UBo;
        uD = M.userData;
        units = uD.targetUnits;
        label = uD.targetLabel;
        
        % Update the Results Listbox and highlight the one just created.
        if isnan(LBo)
            newline = ['Inner bound predicted range for property ' label ' is [' num2str(10^LBi,'%0.2f') ',' ...
                num2str(10^UBi,'%0.2f') '] ' units ' of surrogate model ' mname ' from dataset ' name];
        else %they won't both be nan, since we abort if no bounds are selected
            newline = ['Predicted range for property ' label ' is [' num2str(10^LBo,'%0.2f') ',' num2str(10^UBo,'%0.2f') '] ' ...
                units ' of surrogate model ' mname ' from dataset ' name];
        end
        str = [get(handles.PredResultsLB,'String');{newline}];
        set(handles.PredResultsLB,'String',str)
        set(handles.PredResultsLB,'Value',length(str))
        
        
        %enable context menus
        set([handles.warm_run(2) handles.view_opt(2)],'enable','on')
        
        % Associate this line of the results with this dataset and model
        handles.DatasetUnitInfo(idx).predResults(end+1) = size(str,1);
        handles.ModelInfo(midx).predResults(end+1) = size(str,1);
        
        handles.sessionModified = true;
    else
        errordlg('Must use consistent dataset for prediction.','Dataset is not consistent','modal');
    end
    set(handles.PredPB,'enable','on','BackgroundColor',oldBackgroundColor,...
        'string','Compute Range of Highlighted Model based on Highlighted Dataset')
    guidata(hObject,handles)
catch
    set(handles.PredPB,'enable','on','BackgroundColor',oldBackgroundColor,...
        'string','Compute Range of Highlighted Model based on Highlighted Dataset')
    errordlg([lasterr ': Computation failed'])
end

% --- Executes on button press in FitParamsPB.
function FitParamsPB_Callback(hObject, eventdata, handles) %#ok

import ModelOpt.*

oldBackgroundColor = get(hObject,'BackgroundColor');
set(hObject,'enable','off','string','Busy','BackgroundColor',[0.6 0.1 0.1])
drawnow

idx = get(handles.DsetList(1),'value');
DsetUnit = handles.DatasetUnit{idx};
weights = handles.DatasetUnitInfo(idx).curwt;
%norm = handles.options.paramOptimObjectiveFctnNorm; % 'two' 'one';
% get current (defaults + any selected modifications) parameter assertions for all needed parameters
plist = neededParameters(DsetUnit);
neededParamAss = getParamAss(handles,plist);

%why is this code here? won't there alway be some needed parameters?
if isempty(neededParamAss)
    set(hObject,'enable','on','BackgroundColor',oldBackgroundColor,...
        'string','Fit Model Parameters to Highlighted Dataset')
    guidata(hObject,handles)
    return
end

%Attempt the optimization
try
    Dset = DClab.DCDataset(DsetUnit,neededParamAss); %create the dataset
    str = get(handles.DsetList(1),'String');
    if numel(handles.ModP) > 1
        pstr = get(handles.PDomPU,'String');
        pname = pstr{get(handles.PDomPU,'Value')};
        if strcmp(pname,'default')
            name = str{idx};
        else
            name = [str{idx} ' with param. ranges ' pname ];
        end
    else
        name = str{idx};
    end
    Dset.name = name;
    
    %obj = ParameterOptimization(Dset,handles.options,norm,weights);
    obj = ParameterOptimization(Dset,handles.options,handles.OptimOptns,weights);
    if ~isempty(handles.ParameterOptimization)
        handles.ParameterOptimization{end+1,1} = obj;
    else
        handles.ParameterOptimization = {obj};
    end
    costUB = obj.costUB;
    
    % Update the Results Listbox and highlight the one just created.
    OptimOptns = obj.OptimOptns;
    switch OptimOptns.method
        case 1
            newline = ['Dataset ' name ': the value of LS-H objective function is ' num2str(costUB, '%0.3d')];
        case 2
            newline = ['Dataset ' name ': the value of LS-F objective function is ' num2str(costUB, '%0.3d')];
        case 3
            newline = ['Dataset ' name ': the value of 1N-F objective function is ' num2str(costUB, '%0.3d')];
        case 4
            newline = ['Dataset ' name ': the values of MO-F objective functions are ' num2str(costUB(1), '%0.3d') ', ' num2str(costUB(2), '%0.3d')];
        case 6
            newline = ['Dataset ' name ': the value of LD-H objective function is ' num2str(costUB, '%0.3d')];
    end
    str = [get(handles.OptimResultsLB,'String');{newline}];
    set(handles.OptimResultsLB,'String',str)
    set(handles.OptimResultsLB,'Value',length(str))
    
    % Associate this line of the results with this dataset
    handles.DatasetUnitInfo(idx).optimResults(end+1) = size(str,1);
    
    set(hObject,'enable','on','BackgroundColor',oldBackgroundColor,...
        'string','Fit Model Parameters to Highlighted Dataset')
    handles.sessionModified = true;
    guidata(hObject,handles)
catch
    set(hObject,'enable','on','BackgroundColor',oldBackgroundColor,...
        'string','Fit Model Parameters to Highlighted Dataset')
    errordlg([lasterr ': Computation failed'])
end

function ConsistResultsLB_Callback(hObject, eventdata, handles) %#ok

if strcmp(get(handles.figure1,'SelectionType'),'open')
    elem = get(hObject,'Value');
    ConsistTestViewer(handles.ConsistTest,elem);
end

function PredResultsLB_Callback(hObject, eventdata, handles) %#ok
if strcmp(get(handles.figure1,'SelectionType'),'open')
    elem = get(hObject,'Value');
    PredictionViewer(handles.Prediction,elem);
end

function OptimResultsLB_Callback(hObject, eventdata, handles) %#ok
if strcmp(get(handles.figure1,'SelectionType'),'open')
    elem = get(hObject,'Value');
    ParameterOptimizationViewer(handles.ParameterOptimization,elem);
end


function messageLB_Callback(hObject, eventdata, handles) %#ok

function tabclick_Callback(hObject,eventdata,handles) %#ok
%in original callback from the tabpanel constructor, whereever you see gcbo, replace with the handle
%to the tab you want to display
tpchandles = guihandles(hObject); %when using guihandles,
%  the input can be the handle to any object contained in the figure

if nargin==3 && strcmp(get(hObject,'String'),'Optimize Model Parameters')
    %    msgbox('Feature currently unavailable','We''re sorry','warn','modal')
    %    return
end

%grab user data from the storage object (the last tp handle)
tpctab = get(tpchandles.(get(hObject,'Tag'))(end),'UserData');

%find the handle to the (old) current tab, and darken it
tpchtab = findobj(tpchandles.(tpctab.tag)(end-length(tpctab.names)-1:end-2),'String',tpctab.current);
set(tpchtab,'Units','pixels')
tpcpos = get(tpchtab,'position');
set(tpchtab,'Enable','on','Fontweight','normal','position',[tpcpos(1:3) tpctab.height],'BackGroundColor',tpctab.BackColor,'ForeGroundColor',tpctab.ForeColor);
set(tpchtab,'Units','normalized')

set(hObject,'Units','pixels')
tpcpos = get(hObject,'Position');
set(hObject,'Enable','inactive','Fontweight','bold','Position',tpcpos+[0 0 0 tpctab.outbreak],'BackGroundColor',tpctab.CurrBackColor,'ForeGroundColor',tpctab.CurrForeColor);
set(findobj(tpchandles.(tpctab.tag),'String','backhide'),'position',[tpcpos(1:3) + [1 0 -3] 2]);
set(hObject,'Units','normalized')

%find handles to all the things we need to make invisible
tpcvisoff = [];
for tpci=unique(get(tpchtab,'UserData'));
    tpcvisoff = [tpcvisoff tpchandles.(char(tpci))]; %#ok
end

%find handles to all the things we need to make visible
tpcvison = [];
for tpci=unique(get(hObject,'UserData'));
    tpcvison = [tpcvison tpchandles.(char(tpci))]; %#ok
end
set(tpcvisoff,'Visible','off');
set(tpcvison,'Visible','on');
drawnow;

%update current selected tab in the storage object
tpctab.current = get(hObject,'String');
set(tpchandles.(tpctab.tag)(end),'UserData',tpctab);

%disable EditModel file menu if not in the prediction tab
switch tpctab.current
    case {'Check Consistency', 'Optimize Model'};
        set(tpchandles.EditModel,'enable','off')
        
    case 'Perform Prediction'
        set(tpchandles.EditModel,'enable','on')
    otherwise
        %do nothing
end
%clear tpchandles tpchtab tpci tpcpos tpctab tpcvisoff tpcvison visoff vison

function handles = addguiobj(guiobj,handles)
% add the contents of a guisession object to the current gui handles

set(handles.DsetList,'String',guiobj.DatasetUnit_name);
set(handles.ModelList,'String',guiobj.Model_name);
set(handles.PDomPU,'String',guiobj.ModP_name);
set(handles.ConsistResultsLB,'String',guiobj.ConsistencyTest_name);
set(handles.PredResultsLB,'String',guiobj.ResponsePrediction_name);
set(handles.OptimResultsLB,'String',guiobj.ParameterOptimization_name);

handles.options = guiobj.options;
handles.options.guiHandle = handles.messageLB;
handles.DatasetUnit = guiobj.DatasetUnit_value;
handles.DatasetUnitInfo = guiobj.DatasetUnitInfo;
handles.Model = guiobj.Model_value;
handles.ModP = guiobj.ModP_value;
handles.ConsistTest = guiobj.ConsistencyTest_value;
handles.Prediction = guiobj.ResponsePrediction_value;
handles.ParameterOptimization = guiobj.ParameterOptimization_value;

handles.UnitArray = guiobj.UnitArray;
handles.ParamAss = guiobj.FreeParameter;
handles.MAcell = guiobj.RMcell;

function timer_Callback(varargin)
% This is the callback of the timer. Everytime it executes it checks of the
% listbox has been moved since the previous execution (by comparing the
% current listboxtop to the saved prev. value).

timer = varargin{1};
try
    handles = guidata(timer.UserData); %.UserData is a graphics handle
    refresh(handles.figure1)
    drawnow
catch
    if ~exist('handles','var')
        stop(timer)
        %delete(timer)
    else
        disp([lasterr ': Noncritical error in timer callback'])
    end
end

% File file menu stuff
function File_Callback(hObject, eventdata, handles) %#ok

function prime_Callback(hObject, eventdata, handles) %#ok
msgbox('Feature currently unavailable','We''re sorry','warn','modal')

function Open_Callback(hObject, eventdata, handles) %#ok
currentdir = pwd;
mainpath = fileparts(which('DCsetup'));
savepath = fullfile(mainpath,'savedGUIsessions');
try
    cd(savepath)
catch
    savepath = mainpath;
    cd(savepath)
end
[filename pathname] = uigetfile('*.mat','Select saved session to load');
cd(currentdir)
drawnow

if isnumeric(filename)
    %the user hit cancel
    return
end

varStruct = whos('-file',fullfile(pathname,filename));
idx = strmatch('Guisession',{varStruct.class});
if isempty(idx)
    msgbox('No saved sessions in selected file, please retry','We''re sorry','warn','modal')
    return
elseif length(idx) > 1
    msgbox('Ambiguous: multiple saved sessions in selected file, please retry','We''re sorry','warn','modal')
    return
else
    objName = varStruct(idx(1)).name;
    loadStruct = load(fullfile(pathname,filename),objName);
    handles = addguiobj(loadStruct.(objName),handles);
    guidata(hObject,handles)
end

%set all the listboxes to their first entry
set([handles.DsetList handles.ModelList handles.PDomPU handles.ConsistResultsLB handles.PredResultsLB handles.OptimResultsLB],'Value',1)

if numel(handles.Model) > 0
    set([handles.RemoveM,handles.RenameM],'enable','on')
end
if numel(handles.DatasetUnit) > 0
    set([handles.RemoveD,handles.EditD,handles.ModParam,handles.RenameD],'enable','on')
    set([handles.ConsistPB handles.FitParamsPB handles.tp_OptimizeModelPar_OptimWeightsPB handles.tp_OptimizeModelPar_OptimOptionsPB],'enable','on')
end
if numel(handles.DatasetUnit) > 0 && numel(handles.Model) > 0
    set(handles.PredPB,'enable','on')
end

if numel(handles.ModP) > 1
    
    %hide the panels we don't want to see
    set(handles.tp_CheckConsistency_DsetPanel,'Visible','off')
    set(handles.tp_CheckConsistency_ModelPanel,'Visible','off')
    
    %make visible the panels we want to see by telling the tabpanels what they
    %"contain"
    
    %Optimize Model
    set(handles.tp(11),'UserData',{'tp_PerformPrediction_DsetPanel',...
        'tp_OptimizeModelPar_AnalyzePanel','tp_OptimizeModelPar_OptimWeightsPB','tp_OptimizeModelPar_OptimOptionsPB'});
    %PerformPrediction
    set(handles.tp(12),'UserData',{'tp_PerformPrediction_DsetPanel',...
        'tp_PerformPrediction_ModelPanel','tp_PerformPrediction_AnalyzePanel'});
    
    %CheckConsistency
    set(handles.tp(13),'UserData',{'tp_PerformPrediction_DsetPanel',...
        'tp_CheckConsistency_AnalyzePanel'});
    
    %Now refresh the panel that is currently displayed by simulating a clink on
    %the appropriate tab
    UserData = get(handles.tp(15),'UserData');
    switch UserData.current
        case 'Check Consistency'
            tabclick_Callback(handles.tp(13),eventdata,handles)
        case 'Perform Prediction'
            tabclick_Callback(handles.tp(12),eventdata,handles)
        case 'Optimize Model'
            msgbox('Feature currently unavailable','We''re sorry','warn','modal')
            return
    end
end
handles.fullname = fullfile(pathname,filename);
handles.filename = filename;
set(handles.figure1,'name',[filename ' - Data Collaboration']);
handles.sessionModified = false; %just started fresh
guidata(hObject,handles)
set(handles.Save,'enable','on')

drawnow %refresh the display since it sometimes gets funky
refresh

function SavedBool = Save_Callback(hObject, eventdata, handles) %#ok
SavedBool = false;
mainpath = fileparts(which('DCsetup'));
savepath = fullfile(mainpath,'savedGUIsessions');

%keep users from overwriting the gri file
if strcmp(handles.fullname,fullfile(savepath,'GRI-Mech 3.0.mat'))
    msgbox('File name GRI-Mech 3.0.mat is reserved, use Save As to specify a different name','We''re sorry','warn','modal')
    return
end

%save the session
guiobj = DClab.Guisession(handles); %#ok
save(handles.fullname,'guiobj')
handles.sessionModified = false; %all changes have been saved
guidata(hObject,handles)
SavedBool = true;

function SavedBool = SaveAs_Callback(hObject, eventdata, handles) %#ok
SavedBool = false;
guiobj = DClab.Guisession(handles); %#ok

% change to the savedGUIsessions directory, get the filename, and change
% back
currentdir = pwd;
mainpath = fileparts(which('DCsetup'));
savepath = fullfile(mainpath,'savedGUIsessions');
try
    cd(savepath)
catch
    savepath = mainpath;
    cd(savepath)
end
%uiputfile will take care of any file overwrite issues for us
[filename, pathname] = uiputfile('*.mat', 'Enter filename for saved session');
cd(currentdir)

if isnumeric(filename)
    %the user hit cancel
    return
end

%code for stupid unix bug
if isempty(filename)
    msgbox('Please retry','No filename given','warn','modal')
    return
end

fullname = fullfile(pathname,filename);

%keep users from overwriting the gri file
if strcmp(fullname,fullfile(savepath,'GRI-Mech 3.0.mat'))
    msgbox('File name GRI-Mech 3.0.mat is reserved, please retry','We''re sorry','warn','modal')
    return
end

save(fullname,'guiobj')
handles.fullname = fullname;
handles.filename = filename;
set(handles.figure1,'name',[filename ' - Data Collaboration']);
set(handles.Save,'enable','on') %now allow save action
handles.sessionModified = false; %all changes have been saved
guidata(hObject,handles)
SavedBool = true;

function Close_Callback(hObject, eventdata, handles) %#ok
figure1_CloseRequestFcn(handles.figure1,eventdata, handles)

function figure1_CloseRequestFcn(hObject, eventdata, handles) %#ok

if ~isfield(handles,'sessionModified')
    delete(hObject)
    return
end

%ButtonName = 'No';

ButtonName = questdlg('You are going to exit the program ....','Confirm Close','OK','Cancel','OK');

%{
if handles.sessionModified
    ButtonName = questdlg('Do you want to save the current session?', ...
        'Data Collaboration', ...
        'Yes', 'No', 'Cancel', 'No');
end
%}
switch ButtonName
    case 'OK'
        wait_h = waitbar(0,'Exiting. Please wait ...');
        if isfield(handles,'timer')
            try
                stop(handles.timer);
                %delete(handles.timer);
            catch
                disp('timer stop failed')
                %do nothing
            end
        end
        delete(hObject);
        waitbar(0.8);
        close(wait_h);
        delete(gcf);
    case 'Yes'
        return
        savestate = get(handles.Save,'enable');
        if strcmp(savestate,'off')
            SavedBool = SaveAs_Callback(handles.SaveAs, eventdata, handles);
        else
            SavedBool = Save_Callback(handles.Save, eventdata, handles);
        end
        if SavedBool
            if isfield(handles,'timer')
                try
                    stop(handles.timer);
                    %delete(handles.timer);
                catch
                    disp('timer stop failed')
                    %do nothing
                end
            end
            delete(hObject);
        else
            return
        end
    otherwise
        return
end

% --------------------------------------------------------------------
function Edit_Callback(hObject, eventdata, handles) %#ok

function EditDset_Callback(hObject, eventdata, handles) %#ok

function NewD_Callback(hObject, eventdata, handles) %#ok
DsetPB_Callback(handles.DsetPB(1),eventdata,handles)

function EditD_Callback(hObject, eventdata, handles) %#ok

[out1 out2 out3 out4] = ModDatasetUnits(cellstr(get(handles.DsetList(1),'String')),get(handles.DsetList(1),'Value'),handles.DatasetUnit,handles.DatasetUnitInfo);
set(handles.DsetList,'String',out1,'Value',out2);
handles.DatasetUnit = out3;
if ~isequal(handles.DatasetUnitInfo,out4)
    handles.DatasetUnitInfo = out4;
    handles.sessionModified = true;
end
guidata(hObject,handles)

function RenameD_Callback(hObject, eventdata, handles) %#ok

val = get(handles.DsetList(1),'Value');
str = get(handles.DsetList(1),'String');
currentName = str(val);

%prompt user for new name
prompt={'Enter a new name for the Dataset:'};
name='Rename Dataset';
numlines=1;
defaultanswer=currentName;
newName=inputdlg(prompt,name,numlines,defaultanswer);
if isempty(newName)
    %do nothing, the user hit cancel
elseif isempty(newName{1})
    errordlg('Supplied name is empty, please retry')
elseif ~strcmp(currentName,newName) && ismember(newName,str)
    errordlg('Supplied name is already is use, please retry')
else
    str(val) = newName;
    set(handles.DsetList,'String',str)
end
handles.sessionModified = true;
guidata(hObject,handles)

% --------------------------------------------------------------------
function RemoveD_Callback(hObject, eventdata, handles) %#ok

val = get(handles.DsetList(1),'Value');
str = get(handles.DsetList(1),'String');

if numel(handles.DatasetUnit) <= 1
    %nothing to do? just in case...
    handles.DatasetUnit = {};
    handles.DatasetUnitInfo = struct([]);
    set(handles.DsetList,'String','')
    
    set(handles.ConsistResultsLB,'String',{})
    set(handles.PredResultsLB,'String',{})
    set(handles.OptimResultsLB,'String',{})
    
    handles.ConsistTest = {};
    handles.Prediction = {};
    handles.ParameterOptimization = {};
    
    set([handles.ConsistPB handles.PredPB handles.FitParamsPB handles.tp_OptimizeModelPar_OptimWeightsPB handles.tp_OptimizeModelPar_OptimOptionsPB],'enable','off')
    set([handles.RemoveD,handles.EditD,handles.ModParam,handles.RenameD],'enable','off')
    
else
    consistLinesToRemove = handles.DatasetUnitInfo(val).consistResults;
    predLinesToRemove = handles.DatasetUnitInfo(val).predResults;
    optimLinesToRemove = handles.DatasetUnitInfo(val).optimResults;
    
    handles.DatasetUnit(val) = [];
    handles.DatasetUnitInfo(val) = [];
    str(val) = [];
    
    %if val is bigger than the number of strings now displayed, subtract 1 to
    %keep listbox valid
    if val > size(str,1)
        set(handles.DsetList,'Value',val-1)
        uicontrol(handles.DsetList(1)) %we changed the value in software, so call the control to refresh it graphically
        uicontrol(handles.DsetList(2))
        refresh
    end
    set(handles.DsetList,'String',str)
    
    handles = removeResultsLines(consistLinesToRemove,handles,'consist');
    handles = removeResultsLines(predLinesToRemove,handles,'pred');
    handles = removeResultsLines(optimLinesToRemove,handles,'optim');
    
    handles.ConsistTest(consistLinesToRemove) = [];
    handles.Prediction(predLinesToRemove) = [];
    handles.ParameterOptimization(optimLinesToRemove) = [];
    
end
handles.sessionModified = true;
guidata(hObject,handles)

function ModParam_Callback(hObject, eventdata, handles) %#ok

msgbox('Feature currently unavailable','We''re sorry','warn','modal')

return

uplist = {};
mplist = {};
if numel(handles.DatasetUnit) > 0
    idx = get(handles.DsetList(1),'value');
    DsetUnit = handles.DatasetUnit{idx};
    uplist = neededParameters(DsetUnit);
end
if numel(handles.Model) > 0
    idx = get(handles.ModelList(1),'value');
    M = handles.Model{idx};
    mplist = M.parameterList;
end
plist = unique(vertcat(uplist,mplist));
currentParamAss = getParamAss(handles,plist);

newName = ['mod' num2str(length(handles.ModP))];
newP = gui(currentParamAss);
if isempty(newP)
    %do nothing, no changes were made
    errordlg('No changes were recorded, please retry')
    return
end

handles.ModP{end+1,1} = newP;

str = [get(handles.PDomPU,'String'); {newName}];
set(handles.PDomPU,'String',str)
set(handles.PDomPU,'Value',length(str))
handles.sessionModified = true;
guidata(hObject,handles)

if numel(handles.ModP) == 2
    %we made the first modification---change the display
    
    %hide the panels we don't want to see
    set(handles.tp_CheckConsistency_DsetPanel,'Visible','off')
    set(handles.tp_CheckConsistency_ModelPanel,'Visible','off')
    
    %make visible the panels we want to see by telling the tabpanels what they
    %"contain"
    
    %Optimize Model
    set(handles.tp(11),'UserData',{'tp_PerformPrediction_DsetPanel',...
        'tp_OptimizeModelPar_AnalyzePanel','tp_OptimizeModelPar_OptimWeightsPB','tp_OptimizeModelPar_OptimOptionsPB'});
    
    %PerformPrediction
    set(handles.tp(12),'UserData',{'tp_PerformPrediction_DsetPanel',...
        'tp_PerformPrediction_ModelPanel','tp_PerformPrediction_AnalyzePanel'});
    
    %CheckConsistency
    set(handles.tp(13),'UserData',{'tp_PerformPrediction_DsetPanel',...
        'tp_CheckConsistency_AnalyzePanel'});
    
    %Now refresh the panel that is currently displayed by simulating a clink on
    %the appropriate tab
    UserData = get(handles.tp(15),'UserData');
    switch UserData.current
        case 'Check Consistency'
            tabclick_Callback(handles.tp(13),eventdata,handles)
        case 'Perform Prediction'
            tabclick_Callback(handles.tp(12),eventdata,handles)
        case 'Optimize Model Parameters'
            msgbox('Feature currently unavailable','We''re sorry','warn','modal')
            return
    end
end

guidata(hObject,handles);
%-------------------------------------------------------------------------

% Edit Model file menu stuff
function EditModel_Callback(hObject, eventdata, handles) %#ok

function NewM_Callback(hObject, eventdata, handles) %#ok
ModelPB_Callback(handles.ModelPB(1),eventdata,handles)

function RenameM_Callback(hObject, eventdata, handles) %#ok
val = get(handles.ModelList(1),'Value');
str = get(handles.ModelList(1),'String');
currentName = str(val);

%prompt user for new name
prompt={'Enter a new name for the Model:'};
name='Rename Model';
numlines=1;
defaultanswer=currentName;
newName=inputdlg(prompt,name,numlines,defaultanswer);
if isempty(newName)
    %do nothing: the user hit cancel
elseif isempty(newName{1})
    errordlg('Supplied name is empty, please retry')
elseif ~strcmp(currentName,newName) && ismember(newName,str)
    errordlg('Supplied name is already is use, please retry')
else
    str(val) = newName;
    set(handles.ModelList,'String',str)
end
handles.sessionModified = true;
guidata(hObject,handles)

function RemoveM_Callback(hObject, eventdata, handles) %#ok
val = get(handles.ModelList(1),'Value');
str = get(handles.ModelList(1),'String');
if numel(handles.Model) == 1
    handles.Model = {};
    set(handles.ModelList,'String','')
    set(handles.PredPB,'enable','off')
    set([handles.RemoveM,handles.RenameM],'enable','off')
else
    handles.Model(val) = [];
    str(val) = [];
    %if val is bigger than the number of strings now displayed, subtract 1 to
    %keep listbox valid
    if val > size(str,1)
        set(handles.ModelList,'Value',val-1)
        uicontrol(handles.ModelList(1)) %we changed the value in software, so call the control to refresh it graphically
        uicontrol(handles.ModelList(2))
        refresh
    end
    set(handles.ModelList,'String',str)
end
handles.sessionModified = true;
guidata(hObject,handles)
%------------------------------------------------------------------------

% Analysis Options file menu stuff
function Options_Callback(hObject, eventdata, handles) %#ok

function stdOpt_Callback(hObject, eventdata, handles) %#ok
tmp = handles.options;
handles.options = guiLite(handles.options);
if ~isequal(tmp,handles.options)
    handles.sessionModified = true;
    guidata(hObject,handles)
end

function advOpt_Callback(hObject, eventdata, handles) %#ok
msgbox('Feature currently unavailable','We''re sorry','warn','modal')
return
tmp = handles.options;
handles.options = gui(handles.options);
if ~isequal(tmp,handles.options)
    handles.sessionModified = true;
    guidata(hObject,handles)
end

%-----------------------------------------------------------------------

% Gui options file menu stuff
% --------------------------------------------------------------------
function guioptions_Callback(hObject, eventdata, handles) %#ok

function logon_Callback(hObject, eventdata, handles) %#ok
% push everything up 15 characters on the screen and make the messages
% visible.


%set everything to characters
for i1 = 1:length(handles.tp)
    set(handles.tp(i1),'units','pixels')
end
panels = {'tp_CheckConsistency_AnalyzePanel';'tp_CheckConsistency_DsetPanel'; ...
    'tp_CheckConsistency_ModelPanel';'tp_PerformPrediction_AnalyzePanel'; ...
    'tp_PerformPrediction_ModelPanel';'tp_PerformPrediction_DsetPanel';...
    'tp_OptimizeModelPar_AnalyzePanel';'tp_OptimizeModelPar_OptimWeightsPB';'tp_OptimizeModelPar_OptimOptionsPB'};
for i1 = 1:length(panels)
    set(handles.(panels{i1}),'units','pixels');
end

%resize gui
tmp = get(handles.figure1,'position');
guiht = handles.prevguiheight;
offset = 0.25*guiht;
tmp(4) = guiht+offset;
tmp(2) = tmp(2)-offset;

set(handles.messagepanel,'visible','on')
set(handles.logon,'enable','off')
set(handles.logoff,'enable','on')
set(handles.clearlog,'enable','on')
set(handles.figure1,'position',tmp);

%shift everything up, and set back to normalized
for i1 = 1:length(handles.tp)
    tmp = get(handles.tp(i1),'position');
    tmp(2) = tmp(2)+offset;
    set(handles.tp(i1),'position',tmp);
    set(handles.tp(i1),'units','normalized')
end
tmp = get(handles.tp(end),'userdata');
tmp.pos = get(handles.tp(end),'position');
set(handles.tp(end),'userdata',tmp)

for i1 = 1:length(panels)
    tmp = get(handles.(panels{i1}),'position');
    tmp(2) = tmp(2)+offset;
    set(handles.(panels{i1}),'position',tmp)
    set(handles.(panels{i1}),'units','normalized')
end

function clearlog_Callback(hObject, eventdata, handles) %#ok
set(handles.messageLB,'Value',1)
set(handles.messageLB,'String',{})


function logoff_Callback(hObject, eventdata, handles) %#ok
%hide the messages and push everything down on the screen


%set everything to characters
for i1 = 1:length(handles.tp)
    set(handles.tp(i1),'units','pixels')
end
panels = {'tp_CheckConsistency_AnalyzePanel';'tp_CheckConsistency_DsetPanel'; ...
    'tp_CheckConsistency_ModelPanel';'tp_PerformPrediction_AnalyzePanel'; ...
    'tp_PerformPrediction_ModelPanel';'tp_PerformPrediction_DsetPanel'; ...
    'tp_OptimizeModelPar_AnalyzePanel';'tp_OptimizeModelPar_OptimWeightsPB';'tp_OptimizeModelPar_OptimOptionsPB'};
for i1 = 1:length(panels)
    set(handles.(panels{i1}),'units','pixels');
end

tmp = get(handles.figure1,'position');
guiht = handles.prevguiheight;
offset = (1/4)*guiht;
tmp(4) = guiht;
tmp(2) = tmp(2)+offset;
%handles.currentguiheight = tmp(4); %set this before changing size, so resize function does nothing to tab sizes
guidata(hObject,handles)
set(handles.messagepanel,'visible','off')
set(handles.logoff,'enable','off')
set(handles.clearlog,'enable','off')
set(handles.logon,'enable','on')
set(handles.figure1,'position',tmp);

%shift everything up, and set back to normalized
for i1 = 1:length(handles.tp)
    tmp = get(handles.tp(i1),'position');
    tmp(2) = tmp(2)-offset;
    set(handles.tp(i1),'position',tmp);
    set(handles.tp(i1),'units','normalized')
end
tmp = get(handles.tp(end),'userdata');
tmp.pos = get(handles.tp(end),'position');
set(handles.tp(end),'userdata',tmp)

for i1 = 1:length(panels)
    tmp = get(handles.(panels{i1}),'position');
    tmp(2) = tmp(2)-offset;
    set(handles.(panels{i1}),'position',tmp)
    set(handles.(panels{i1}),'units','normalized')
end

function guismall_Callback(hObject, eventdata, handles) %#ok
%make the gui as small as possible without having to screw much with font sizes

%original height and width in pixels
pxwid = 910;
pxht = 586;

%(at least in windows, we're ok with a width of 730)
newwid = 730;
scale = newwid/pxwid;

messageon = strcmp(get(handles.messagepanel,'Visible'),'on');
if messageon
    newht = pxht*1.25*scale; %25% bigger with message showing
else
    newht = pxht*scale;
end
%handles.currentguiheight = pxht; %*scale; %save no message height
guidata(hObject,handles)

scrnsize = get(0,'ScreenSize');

newpos(1) = (scrnsize(3)-newwid)/2;
if messageon
    newpos(2) = (scrnsize(4)-newht)/2;
else
    newpos(2) = (scrnsize(4)-newht)/2 + 0.125*newht; %bias up for message room
end
newpos(3) = newwid;
newpos(4) = newht;
set(handles.figure1,'Position',newpos)

%call resize function to restore the tab sizes
%figure1_ResizeFcn(handles.figure1, eventdata, handles)


function normsizegui_Callback(hObject, eventdata, handles) %#ok
%original height and width in pixels
pxwid = 910;
pxht = 586;

newwid = pxwid;
messageon = strcmp(get(handles.messagepanel,'Visible'),'on');
if messageon
    newht = pxht*1.25; %25% bigger with message showing
else
    newht = pxht;
end
%handles.currentguiheight = pxht; %save no message height

scrnsize = get(0,'ScreenSize');

newpos(1) = (scrnsize(3)-newwid)/2;
if messageon
    newpos(2) = min((scrnsize(4)-newht-50)/2,scrnsize(4)-newht-50); %make sure there's room
else
    newpos(2) = min((scrnsize(4)-newht)/2 + 0.125*newht,scrnsize(4)-1.1*newht); %make sure there's room
end

newpos(3) = newwid;
newpos(4) = newht;
set(handles.figure1,'Position',newpos)

%--------------------------------------------------------------

% Help file menu stuff
function Help_Callback(hObject, eventdata, handles) %#ok

function GUIHelp_Callback(hObject, eventdata, handles) %#ok
web(fullfile(fileparts(which('DCsetup')), 'docs', 'html', 'gui.html'), '-helpbrowser')

function About_Callback(hObject, eventdata, handles) %#ok

s = {'The Data Collaboration software was created at the Berkeley Center for Control and Identification at UC Berkeley. Supported by the NSF under grant no. CTS-0113985 (http://jagger.me.berkeley.edu/~pack/nsfuncertainty) and grant no. CHE-0535542'; ...
    ''; ...
    'The interface between Data Collaboration and PrIMe (http://primekinetics.org) was developed by Xiaoqing You, Trent Russi, and Michael Frenklach.'; ...
    ''; ...
    'The Consistency check and Model prediction codes were modified by Trent Russi and Xiaoqing You to process the PrIMe data.'; ...
    ''; ...
    'The Parameter Optimization code was developed by Xiaoqing You and Michael Frenklach.'; ...
    ''; ...
    'References: ';...
    'Feeley R., Seiler P., Packard, A., Frenklach, M., J. Phys. Chem. A, 2004, 108 (44), 9573.'; ...
    'Frenklach, M., Packard, A., Seiler P.,Feeley R., Int. J. Chem. Kinet., 2004, 36, 57.'; ...
    'Frenklach, M., Proc. Combust. Inst., 2007, 31, 125.'; ...
    'Russi, T., Packard, A., Feeley, R., Frenklach, M., J. Phys. Chem. A, 2008, 112 (12), 2579.'; ...
    'You, X.Q., Russi, T., Yeates, D., Packard, A., Frenklach, M., the 6th U.S. National Combustion Meeting, May 17-20, 2009, Ann Arbor, Michigan.';};

msgbox(s,'About','none','modal');

% --- Executes when figure1 is resized.
function figure1_ResizeFcn(hObject, eventdata, handles) %#ok
% hObject    handle to figure1 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% This function adjusts the stored tab sizes as a function of the new gui size.

if isfield(handles,'prevguiheight')
    guipos = get(handles.figure1,'position');
    ht = guipos(4);
    messageon = strcmp(get(handles.messagepanel,'Visible'),'on');
    if messageon
        scale = 0.8*ht/handles.prevguiheight;
        handles.prevguiheight = 0.8*ht;
    else
        scale = ht/handles.prevguiheight;
        handles.prevguiheight = ht;
    end%if
    guidata(hObject,handles)
    tpctab = get(handles.tp(end),'UserData');
    tpctab.height = scale*tpctab.height;
    tpctab.outbreak = scale*tpctab.outbreak;
    set(handles.tp(end),'UserData',tpctab);
    
    
    if guipos(3) < 810
        set(handles.ModelPB(1),'String','Add New Observable')
        set(handles.ModelPB(2),'String','Add New Observable')
    else
        set(handles.ModelPB(1),'String','Add New Observable')
        set(handles.ModelPB(2),'String','Add New Observable')
    end
    
    %         set([handles.ConsistPB handles.PredPB handles.FitParamsPB],'fontsize',10)
    %         set(handles.ModelPB,'fontsize',8)
    %         %set(handles.tp_CheckConsistency_DsetPanel,'fontsize',10)
    %         %set(handles.tp_PerformPrediction_ModelPanel,'fontsize',10)
    %         %set(handles.tp_PerformPrediction_DsetPanel,'fontsize',10)
    %     else
    %         set([handles.ConsistPB handles.PredPB handles.FitParamsPB],'fontsize',12)
    %         set(handles.ModelPB,'fontsize',10)
    %         %set(handles.tp_CheckConsistency_DsetPanel,'fontsize',12)
    %         %set(handles.tp_PerformPrediction_ModelPanel,'fontsize',12)
    %         %set(handles.tp_PerformPrediction_DsetPanel,'fontsize',12)
    %     end
end

% --------------------------------------------------------------------

function tp_OptimizeModelPar_OptimWeightsPB_Callback(hObject, eventdata, handles) %#ok

[newInfo] = ModUnitWeights(cellstr(get(handles.DsetList(1),'String')),get(handles.DsetList(1),'Value'),handles.DatasetUnit,handles.DatasetUnitInfo);
if ~isequal(handles.DatasetUnitInfo,newInfo)
    handles.DatasetUnitInfo = newInfo;
    handles.sessionModified = true;
end
guidata(hObject,handles)


function tp_OptimizeModelPar_OptimOptionsPB_Callback(hObject, eventdata, handles) %#ok
handles.OptimOptns = OptimOptions(handles.OptimOptns);
guidata(hObject,handles)

function handles = removeResultsLines(lineNums,handles,resultsType)

switch resultsType
    case 'consist'
        LBname = 'ConsistResultsLB';
    case 'pred'
        LBname = 'PredResultsLB';
    case 'optim'
        LBname = 'OptimResultsLB';
    otherwise
        error('condition should never occur')
end

%sort lineNums so we remove from largest to smallest. This leave the lower
%numbers unchanged as we progress.
lineNums = sort(lineNums,'descend');

for i1 = 1:length(lineNums)
    for i2 = 1:length(handles.DatasetUnitInfo)
        lines = handles.DatasetUnitInfo(i2).([resultsType 'Results']);
        toDecrease = lines > lineNums(i1);
        lines(toDecrease) = lines(toDecrease) - 1;
        handles.DatasetUnitInfo(i2).([resultsType 'Results']) = lines;
    end
end

%Remove results from display
resultsStr = get(handles.(LBname),'String');
if length(lineNums) == size(resultsStr,1)
    resultsStr = {};
else
    resultsStr(lineNums) = [];
end

val = get(handles.(LBname),'Value');
%if val is bigger than the number of strings now displayed, modify to
%keep listbox valid
if val > size(resultsStr,1)
    set(handles.(LBname),'Value',max(size(resultsStr,1),1))
    uicontrol(handles.(LBname)) %we changed the value in software, so call the control to refresh it graphically
    refresh
end
set(handles.(LBname),'String',resultsStr)





% --------------------------------------------------------------------
function view_opt_Callback(hObject, eventdata, handles)
% hObject    handle to view_opt (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
opts = [];
if any(get(handles.tp(10),'foregroundcolor')>0.5) %consist
    elem = get(handles.ConsistResultsLB,'Value');
    opts = handles.ConsistTest{elem}.optimOpts;
elseif any(get(handles.tp(11),'foregroundcolor')>0.5) %predict
    elem = get(handles.PredResultsLB,'Value');
    opts = handles.Prediction{elem}.optimOpts;
end
if ~isempty(opts)
    if opts.omitInnerBound
        inner = 'not calculated';
    else
        inner = 'calculated';
    end
    if opts.omitOuterBound
        outer = 'not calculated';
    else
        outer = 'calculated';
    end
    s = {'Options used:';...
        '';'';...
        ['Inner bounds: ' inner];...
        ['Outer bounds: ' outer];...
        ['Max. Branch and Bound Iterations: ' num2str(opts.maxBranchBoundIter)];...
        ['Branch and Bound termination tolerance: ' num2str(opts.branchBoundTermTol)];...
        ['Objective convergence tolerance: ' num2str(opts.tolFun)];...
        ['Number of inner-bound restarts:  ' num2str(opts.nRestart)]};
    msgbox(s,'Options used','none','modal');
end
    


% --------------------------------------------------------------------
function warm_run_Callback(hObject, eventdata, handles)
% hObject    handle to warm_run (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

if any(get(handles.tp(10),'foregroundcolor')>0.5) %consist
    if handles.options.omitInnerBound && handles.options.omitOuterBound
        msgbox('All bounds are disabled, modify the analysis options and retry','We''re sorry','warn','modal')
        return
    end
    
    oldBackgroundColor = get(handles.ConsistPB,'BackgroundColor');
    set(handles.ConsistPB,'enable','off','string','Busy','BackgroundColor',[0.6 0.1 0.1])
    drawnow
    
    %idx = get(handles.DsetList(1),'value');
    %DsetUnit = handles.DatasetUnit{idx};
    
    elem = get(handles.ConsistResultsLB,'Value');
    ctest = handles.ConsistTest{elem};
    
    idx = [];
    for i=1:length(handles.DatasetUnitInfo)
        if any(handles.DatasetUnitInfo(i).consistResults==elem)
            idx = i;
        end
    end
    
    
    %Attempt the the consistency test
    try
        
        name = ctest.Dataset.name;
        
        %Perform the Consistency Test
        obj = DClab.ConsistencyTest(ctest,handles.options);
        LB = obj.LB;
        UB = obj.UB;
        if ~isempty(handles.ConsistTest)
            handles.ConsistTest{end+1,1} = obj;
        else
            handles.ConsistTest = {obj};
        end
        
        %Create the result display string
        if isnan(LB)
            if UB < 0
                newline = ['Dataset ' name ' is inconsistent: consistency measure upper bound is ' num2str(UB,'%0.2f')];
            else
                newline = ['Consistency of Dataset ' name ' is inconclusive: consistency measure upper bound is ' num2str(UB,'%0.2f')];
            end
        elseif isnan(UB)
            if LB > 0
                newline = ['Dataset ' name ' is consistent: consistency measure lower bound is ' num2str(LB,'%0.2f')];
            else
                newline = ['Consistency of Dataset ' name ' is inconclusive: consistency measure lower bound is ' num2str(LB,'%0.2f')];
            end
        else %they won't both be nan, since we abort if no bounds are selected
            if LB > 0
                newline = ['Dataset ' name ' is consistent: measure in [' num2str(LB,'%0.2f') ', ' num2str(UB,'%0.2f') ']'];
            elseif UB < 0
                newline = ['Dataset ' name ' is inconsistent: measure in [' num2str(LB,'%0.2f') ', ' num2str(UB,'%0.2f') ']'];
            else
                newline = ['Consistency of Dataset' name ' is inconclusive: measure in [' num2str(LB,'%0.2f') ', ' num2str(UB,'%0.2f') ']'];
            end
        end
        % Update the Results Listbox and highlight the one just created.
        str = [get(handles.ConsistResultsLB,'String');{newline}];
        set(handles.ConsistResultsLB,'String',str)
        set(handles.ConsistResultsLB,'Value',length(str))
        
        % Associate this line of the results with this dataset
        handles.DatasetUnitInfo(idx).consistResults(end+1) = length(str);
        
        set(handles.ConsistPB,'enable','on','backgroundColor',...
            oldBackgroundColor,'string','Check Consistency of Highlighted Dataset')
        handles.sessionModified = true;
        guidata(hObject,handles)
    catch
        set(handles.ConsistPB,'enable','on','backgroundColor',...
            oldBackgroundColor,'string','Check Consistency of Highlighted Dataset')
        errordlg([lasterr ': Computation failed'])
    end
elseif any(get(handles.tp(11),'foregroundcolor')>0.5) %predict
    if handles.options.omitInnerBound && handles.options.omitOuterBound
        msgbox('All bounds are disabled, modify the analysis options and retry','We''re sorry','warn','modal')
        return
    end
    
    oldBackgroundColor = get(hObject,'BackgroundColor');
    set(handles.PredPB,'enable','off','string','Busy','BackgroundColor',[0.6 0.1 0.1])
    drawnow
    
    %idx = get(handles.DsetList(1),'value');
    %DsetUnit = handles.DatasetUnit{idx};
    elem = get(handles.PredResultsLB,'Value');
    pred = handles.Prediction{elem};
    
    idx = [];
    for i=1:length(handles.DatasetUnitInfo)
        if any(handles.DatasetUnitInfo(i).predResults==elem)
            idx = i;
        end
    end
    
    midx = [];
    for i=1:length(handles.ModelInfo)
        if any(handles.ModelInfo(i).predResults==elem)
            idx = i;
        end
    end
    
    %Attempt the the prediction call
    try
        
        mname = pred.ResponseModel.name;
        name = pred.Dataset.name;
        
        %Call the prediction code
        obj = DClab.ResponsePrediction(pred,handles.options);
        if ~isempty(handles.Prediction)
            handles.Prediction{end+1,1} = obj;
        else
            handles.Prediction = {obj};
        end
        LBo = obj.LBo;
        LBi = obj.LBi;
        UBi = obj.UBi;
        UBo = obj.UBo;
        uD = M.userData;
        units = uD.targetUnits;
        label = uD.targetLabel;
        
        % Update the Results Listbox and highlight the one just created.
        if isnan(LBo)
            newline = ['Inner bound predicted range for property ' label ' is [' num2str(10^LBi,'%0.2f') ',' ...
                num2str(10^UBi,'%0.2f') '] ' units ' of surrogate model ' mname ' from dataset ' name];
        else %they won't both be nan, since we abort if no bounds are selected
            newline = ['Predicted range for property ' label ' is [' num2str(10^LBo,'%0.2f') ',' num2str(10^UBo,'%0.2f') '] ' ...
                units ' of surrogate model ' mname ' from dataset ' name];
        end
        str = [get(handles.PredResultsLB,'String');{newline}];
        set(handles.PredResultsLB,'String',str)
        set(handles.PredResultsLB,'Value',length(str))
        
        % Associate this line of the results with this dataset and model
        handles.DatasetUnitInfo(idx).predResults(end+1) = size(str,1);
        handles.ModelInfo(midx).predResults(end+1) = size(str,1);
        
        handles.sessionModified = true;
        
        set(handles.PredPB,'enable','on','BackgroundColor',oldBackgroundColor,...
            'string','Compute Range of Highlighted Model based on Highlighted Dataset')
        guidata(hObject,handles)
    catch
        set(handles.PredPB,'enable','on','BackgroundColor',oldBackgroundColor,...
            'string','Compute Range of Highlighted Model based on Highlighted Dataset')
        errordlg([lasterr ': Computation failed'])
    end

end


% --------------------------------------------------------------------
function opt_context_Callback(hObject, eventdata, handles)
% hObject    handle to opt_context (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function tp_CheckConsistency_opt_context_Callback(hObject, eventdata, handles)
% hObject    handle to tp_CheckConsistency_opt_context (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function tp_PerformPrediction_opt_context_Callback(hObject, eventdata, handles)
% hObject    handle to tp_PerformPrediction_opt_context (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
